/*
 * generated by Xtext
 */
package de.cau.cs.se.instrumentation.al.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import de.cau.cs.kieler.core.annotations.Annotation;
import de.cau.cs.kieler.core.annotations.AnnotationsPackage;
import de.cau.cs.kieler.core.annotations.BooleanAnnotation;
import de.cau.cs.kieler.core.annotations.FloatAnnotation;
import de.cau.cs.kieler.core.annotations.ImportAnnotation;
import de.cau.cs.kieler.core.annotations.IntAnnotation;
import de.cau.cs.kieler.core.annotations.StringAnnotation;
import de.cau.cs.kieler.core.annotations.TypedStringAnnotation;
import de.cau.cs.kieler.core.annotations.text.serializer.AnnotationsSemanticSequencer;
import de.cau.cs.se.instrumentation.al.aspectLang.Advice;
import de.cau.cs.se.instrumentation.al.aspectLang.ApplicationModel;
import de.cau.cs.se.instrumentation.al.aspectLang.Aspect;
import de.cau.cs.se.instrumentation.al.aspectLang.AspectLangPackage;
import de.cau.cs.se.instrumentation.al.aspectLang.Collector;
import de.cau.cs.se.instrumentation.al.aspectLang.CompositionQuery;
import de.cau.cs.se.instrumentation.al.aspectLang.ContainerNode;
import de.cau.cs.se.instrumentation.al.aspectLang.Event;
import de.cau.cs.se.instrumentation.al.aspectLang.FloatValue;
import de.cau.cs.se.instrumentation.al.aspectLang.Import;
import de.cau.cs.se.instrumentation.al.aspectLang.IntValue;
import de.cau.cs.se.instrumentation.al.aspectLang.InternalFunctionProperty;
import de.cau.cs.se.instrumentation.al.aspectLang.LocationQuery;
import de.cau.cs.se.instrumentation.al.aspectLang.MethodQuery;
import de.cau.cs.se.instrumentation.al.aspectLang.Model;
import de.cau.cs.se.instrumentation.al.aspectLang.ParamExpression;
import de.cau.cs.se.instrumentation.al.aspectLang.ParamQuery;
import de.cau.cs.se.instrumentation.al.aspectLang.ParameterDeclaration;
import de.cau.cs.se.instrumentation.al.aspectLang.ParameterQuery;
import de.cau.cs.se.instrumentation.al.aspectLang.ParentNode;
import de.cau.cs.se.instrumentation.al.aspectLang.Pointcut;
import de.cau.cs.se.instrumentation.al.aspectLang.ReferenceValue;
import de.cau.cs.se.instrumentation.al.aspectLang.ReflectionProperty;
import de.cau.cs.se.instrumentation.al.aspectLang.RuntimeProperty;
import de.cau.cs.se.instrumentation.al.aspectLang.StringValue;
import de.cau.cs.se.instrumentation.al.aspectLang.SubPathNode;
import de.cau.cs.se.instrumentation.al.aspectLang.UtilizeAdvice;
import de.cau.cs.se.instrumentation.al.aspectLang.WildcardNode;
import de.cau.cs.se.instrumentation.al.services.AspectLangGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class AspectLangSemanticSequencer extends AnnotationsSemanticSequencer {

	@Inject
	private AspectLangGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == AnnotationsPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case AnnotationsPackage.ANNOTATION:
				sequence_TagAnnotation(context, (Annotation) semanticObject); 
				return; 
			case AnnotationsPackage.BOOLEAN_ANNOTATION:
				sequence_KeyBooleanValueAnnotation(context, (BooleanAnnotation) semanticObject); 
				return; 
			case AnnotationsPackage.FLOAT_ANNOTATION:
				sequence_KeyFloatValueAnnotation(context, (FloatAnnotation) semanticObject); 
				return; 
			case AnnotationsPackage.IMPORT_ANNOTATION:
				sequence_ImportAnnotation(context, (ImportAnnotation) semanticObject); 
				return; 
			case AnnotationsPackage.INT_ANNOTATION:
				sequence_KeyIntValueAnnotation(context, (IntAnnotation) semanticObject); 
				return; 
			case AnnotationsPackage.STRING_ANNOTATION:
				if(context == grammarAccess.getAnnotationRule() ||
				   context == grammarAccess.getValuedAnnotationRule()) {
					sequence_Annotation_CommentAnnotation_KeyStringValueAnnotation(context, (StringAnnotation) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getCommentAnnotationRule()) {
					sequence_CommentAnnotation(context, (StringAnnotation) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getKeyStringValueAnnotationRule()) {
					sequence_KeyStringValueAnnotation(context, (StringAnnotation) semanticObject); 
					return; 
				}
				else break;
			case AnnotationsPackage.TYPED_STRING_ANNOTATION:
				sequence_TypedKeyStringValueAnnotation(context, (TypedStringAnnotation) semanticObject); 
				return; 
			}
		else if(semanticObject.eClass().getEPackage() == AspectLangPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case AspectLangPackage.ADVICE:
				sequence_Advice(context, (Advice) semanticObject); 
				return; 
			case AspectLangPackage.APPLICATION_MODEL:
				sequence_ApplicationModel(context, (ApplicationModel) semanticObject); 
				return; 
			case AspectLangPackage.ASPECT:
				sequence_Aspect(context, (Aspect) semanticObject); 
				return; 
			case AspectLangPackage.COLLECTOR:
				sequence_Collector(context, (Collector) semanticObject); 
				return; 
			case AspectLangPackage.COMPOSITION_QUERY:
				sequence_CompositionQuery(context, (CompositionQuery) semanticObject); 
				return; 
			case AspectLangPackage.CONTAINER_NODE:
				if(context == grammarAccess.getContainerNodeRule()) {
					sequence_ContainerNode(context, (ContainerNode) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getNodeRule()) {
					sequence_ContainerNode_Node(context, (ContainerNode) semanticObject); 
					return; 
				}
				else break;
			case AspectLangPackage.EVENT:
				sequence_Event(context, (Event) semanticObject); 
				return; 
			case AspectLangPackage.FLOAT_VALUE:
				sequence_FloatValue(context, (FloatValue) semanticObject); 
				return; 
			case AspectLangPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case AspectLangPackage.INT_VALUE:
				sequence_IntValue(context, (IntValue) semanticObject); 
				return; 
			case AspectLangPackage.INTERNAL_FUNCTION_PROPERTY:
				sequence_InternalFunctionProperty(context, (InternalFunctionProperty) semanticObject); 
				return; 
			case AspectLangPackage.LOCATION_QUERY:
				sequence_LocationQuery(context, (LocationQuery) semanticObject); 
				return; 
			case AspectLangPackage.METHOD_QUERY:
				sequence_MethodQuery(context, (MethodQuery) semanticObject); 
				return; 
			case AspectLangPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case AspectLangPackage.PARAM_EXPRESSION:
				if(context == grammarAccess.getParamCompareRule() ||
				   context == grammarAccess.getParamOperatorAccess().getParamExpressionLeftAction_1_0()) {
					sequence_ParamCompare(context, (ParamExpression) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getParamOperatorRule()) {
					sequence_ParamCompare_ParamOperator(context, (ParamExpression) semanticObject); 
					return; 
				}
				else break;
			case AspectLangPackage.PARAM_QUERY:
				sequence_ParamQuery(context, (ParamQuery) semanticObject); 
				return; 
			case AspectLangPackage.PARAMETER_DECLARATION:
				sequence_ParameterDeclaration(context, (ParameterDeclaration) semanticObject); 
				return; 
			case AspectLangPackage.PARAMETER_QUERY:
				sequence_ParameterQuery(context, (ParameterQuery) semanticObject); 
				return; 
			case AspectLangPackage.PARENT_NODE:
				if(context == grammarAccess.getNodeRule()) {
					sequence_Node(context, (ParentNode) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getParentNodeRule()) {
					sequence_ParentNode(context, (ParentNode) semanticObject); 
					return; 
				}
				else break;
			case AspectLangPackage.POINTCUT:
				sequence_Pointcut(context, (Pointcut) semanticObject); 
				return; 
			case AspectLangPackage.REFERENCE_VALUE:
				sequence_ReferenceValue(context, (ReferenceValue) semanticObject); 
				return; 
			case AspectLangPackage.REFLECTION_PROPERTY:
				sequence_ReflectionProperty(context, (ReflectionProperty) semanticObject); 
				return; 
			case AspectLangPackage.RUNTIME_PROPERTY:
				sequence_RuntimeProperty(context, (RuntimeProperty) semanticObject); 
				return; 
			case AspectLangPackage.STRING_VALUE:
				sequence_StringValue(context, (StringValue) semanticObject); 
				return; 
			case AspectLangPackage.SUB_PATH_NODE:
				if(context == grammarAccess.getNodeRule()) {
					sequence_Node(context, (SubPathNode) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getSubPathNodeRule()) {
					sequence_SubPathNode(context, (SubPathNode) semanticObject); 
					return; 
				}
				else break;
			case AspectLangPackage.UTILIZE_ADVICE:
				sequence_UtilizeAdvice(context, (UtilizeAdvice) semanticObject); 
				return; 
			case AspectLangPackage.WILDCARD_NODE:
				if(context == grammarAccess.getNodeRule()) {
					sequence_Node(context, (WildcardNode) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getWildcardNodeRule()) {
					sequence_WildcardNode(context, (WildcardNode) semanticObject); 
					return; 
				}
				else break;
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (name=ID (parameterDeclarations+=ParameterDeclaration parameterDeclarations+=ParameterDeclaration*)? collectors+=Collector*)
	 */
	protected void sequence_Advice(EObject context, Advice semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (handler=ID name=ID model=STRING)
	 */
	protected void sequence_ApplicationModel(EObject context, ApplicationModel semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, AspectLangPackage.Literals.APPLICATION_MODEL__HANDLER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AspectLangPackage.Literals.APPLICATION_MODEL__HANDLER));
			if(transientValues.isValueTransient(semanticObject, AspectLangPackage.Literals.APPLICATION_MODEL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AspectLangPackage.Literals.APPLICATION_MODEL__NAME));
			if(transientValues.isValueTransient(semanticObject, AspectLangPackage.Literals.APPLICATION_MODEL__MODEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AspectLangPackage.Literals.APPLICATION_MODEL__MODEL));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getApplicationModelAccess().getHandlerIDTerminalRuleCall_1_0(), semanticObject.getHandler());
		feeder.accept(grammarAccess.getApplicationModelAccess().getNameIDTerminalRuleCall_3_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getApplicationModelAccess().getModelSTRINGTerminalRuleCall_4_0(), semanticObject.getModel());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (pointcut=[Pointcut|QualifiedName] advices+=UtilizeAdvice advices+=UtilizeAdvice*)
	 */
	protected void sequence_Aspect(EObject context, Aspect semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (insertionPoint=InsertionPoint events+=Event+)
	 */
	protected void sequence_Collector(EObject context, Collector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (modifier=QueryModifier? subQueries+=LocationQuery*)
	 */
	protected void sequence_CompositionQuery(EObject context, CompositionQuery semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     container=[Container|ID]
	 */
	protected void sequence_ContainerNode(EObject context, ContainerNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (container=[Container|ID] parameter=ParamQuery?)
	 */
	protected void sequence_ContainerNode_Node(EObject context, ContainerNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type=[RecordType|QualifiedName] (initializations+=Value initializations+=Value*)?)
	 */
	protected void sequence_Event(EObject context, Event semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=FLOAT
	 */
	protected void sequence_FloatValue(EObject context, FloatValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     importedNamespace=QualifiedNameWithWildcard
	 */
	protected void sequence_Import(EObject context, Import semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, AspectLangPackage.Literals.IMPORT__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AspectLangPackage.Literals.IMPORT__IMPORTED_NAMESPACE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getImportAccess().getImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_IntValue(EObject context, IntValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     function=InternalFunction
	 */
	protected void sequence_InternalFunctionProperty(EObject context, InternalFunctionProperty semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, AspectLangPackage.Literals.INTERNAL_FUNCTION_PROPERTY__FUNCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AspectLangPackage.Literals.INTERNAL_FUNCTION_PROPERTY__FUNCTION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getInternalFunctionPropertyAccess().getFunctionInternalFunctionEnumRuleCall_0(), semanticObject.getFunction());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (node=Node (specialization=LocationQuery | composition=CompositionQuery)?)
	 */
	protected void sequence_LocationQuery(EObject context, LocationQuery semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         modifier=[MethodModifier|ID]? 
	 *         returnType=[Type|ID]? 
	 *         (methodReference=[Method|ID] (parameterQueries+=ParameterQuery parameterQueries+=ParameterQuery*)?)?
	 *     )
	 */
	protected void sequence_MethodQuery(EObject context, MethodQuery semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=QualifiedName imports+=Import* sources+=ApplicationModel* (advices+=Advice | pointcuts+=Pointcut | aspects+=Aspect)*)
	 */
	protected void sequence_Model(EObject context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (parameter=ParamQuery?)
	 */
	protected void sequence_Node(EObject context, ParentNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (parameter=ParamQuery?)
	 */
	protected void sequence_Node(EObject context, SubPathNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (parameter=ParamQuery?)
	 */
	protected void sequence_Node(EObject context, WildcardNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=ParamCompare_ParamExpression_1_0 operator=LogicOperator right=Value)
	 */
	protected void sequence_ParamCompare(EObject context, ParamExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (left=ParamOperator_ParamExpression_1_0 logic=LogicOperator right=ParamCompare) | 
	 *         (left=ParamCompare_ParamExpression_1_0 operator=LogicOperator right=Value)
	 *     )
	 */
	protected void sequence_ParamCompare_ParamOperator(EObject context, ParamExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     queries+=ParamOperator+
	 */
	protected void sequence_ParamQuery(EObject context, ParamQuery semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type='type' name=ID)
	 */
	protected void sequence_ParameterDeclaration(EObject context, ParameterDeclaration semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, AspectLangPackage.Literals.PARAMETER_DECLARATION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AspectLangPackage.Literals.PARAMETER_DECLARATION__TYPE));
			if(transientValues.isValueTransient(semanticObject, AspectLangPackage.Literals.PARAMETER_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AspectLangPackage.Literals.PARAMETER_DECLARATION__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getParameterDeclarationAccess().getTypeTypeKeyword_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getParameterDeclarationAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (modifier=[ParameterModifier|ID]? type=[Type|ID] parameter=[Parameter|ID]?)
	 */
	protected void sequence_ParameterQuery(EObject context, ParameterQuery semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     {ParentNode}
	 */
	protected void sequence_ParentNode(EObject context, ParentNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (annotation=Annotation? name=ID location=LocationQuery method=MethodQuery?)
	 */
	protected void sequence_Pointcut(EObject context, Pointcut semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (query=LocationQuery? parameter=Parameter)
	 */
	protected void sequence_ReferenceValue(EObject context, ReferenceValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     function=ReflectionFunction
	 */
	protected void sequence_ReflectionProperty(EObject context, ReflectionProperty semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, AspectLangPackage.Literals.REFLECTION_PROPERTY__FUNCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AspectLangPackage.Literals.REFLECTION_PROPERTY__FUNCTION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getReflectionPropertyAccess().getFunctionReflectionFunctionEnumRuleCall_1_0(), semanticObject.getFunction());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     reference=ID
	 */
	protected void sequence_RuntimeProperty(EObject context, RuntimeProperty semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, AspectLangPackage.Literals.RUNTIME_PROPERTY__REFERENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AspectLangPackage.Literals.RUNTIME_PROPERTY__REFERENCE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRuntimePropertyAccess().getReferenceIDTerminalRuleCall_1_0(), semanticObject.getReference());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_StringValue(EObject context, StringValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     {SubPathNode}
	 */
	protected void sequence_SubPathNode(EObject context, SubPathNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (advice=[Advice|QualifiedName] (parameterAssignments+=Value parameterAssignments+=Value*)?)
	 */
	protected void sequence_UtilizeAdvice(EObject context, UtilizeAdvice semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     {WildcardNode}
	 */
	protected void sequence_WildcardNode(EObject context, WildcardNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}
