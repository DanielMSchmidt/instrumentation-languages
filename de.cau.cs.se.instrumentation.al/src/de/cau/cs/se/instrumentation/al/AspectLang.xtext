grammar de.cau.cs.se.instrumentation.al.AspectLang with 
org.eclipse.xtext.common.Terminals
// de.cau.cs.kieler.core.annotations.text.Annotations 

generate aspectLang "http://www.cau.de/cs/se/instrumentation/al/AspectLang"

//import "http://kieler.cs.cau.de/annotations" as annotations
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://www.cau.de/cs/se/instrumentation/rl/RecordLang" as irl
// import "platform:/resource/de.cau.cs.se.instrumentation.rl/model/generated/RecordLang.ecore" as irl
import "http://modelstructure.se.cs.cau.de/structure" as structure

AspectModel:
	'package' name = QualifiedName
	(imports += Import)*
	(sources += ApplicationModel)*
	(advices += Advice | pointcuts+=Pointcut | aspects += Aspect)*
;

Import:
	'import' importedNamespace = QualifiedNameWithWildcard
;

ApplicationModel:
	'use' handler=ID 'on' name=ID model=STRING 
;

Aspect:
	'aspect' pointcut=[Pointcut|QualifiedName] ':' advices+=UtilizeAdvice (',' advices+=UtilizeAdvice)* 
;

UtilizeAdvice:
	advice=[Advice|QualifiedName]
	('(' (parameterAssignments+=Value (',' parameterAssignments+=Value)*)? ')')?
;

/* ------------------------------- */
/* advice                          */

Advice:
	'advice' name=ID ('(' (parameterDeclarations+=AdviceParameterDeclaration (',' parameterDeclarations+=AdviceParameterDeclaration)*)? ')')? '{'
		collectors+=Collector*
	'}'
;

AdviceParameterDeclaration:
	type='type' name=ID 
;

Collector:
	insertionPoint=InsertionPoint events+=Event+
;

Event:
	type=[irl::RecordType|QualifiedName] '(' (initializations+=Value (',' initializations+=Value)*)? ')'
;

enum InsertionPoint: 
	BEFORE = 'before' |
	AFTER = 'after'
;

Value:
	Literal | ReferenceValue
;

ReferenceValue:
	(query=LocationQuery)? property=Property	
;

Property:
	InternalFunctionProperty | ReflectionProperty
;

InternalFunctionProperty:
	function=InternalFunction
;

enum InternalFunction:
	TIME = 'time' |
	TRACE_ID = 'traceId' |
	ORDER_INDEX = 'orderIndex'
;

ReflectionProperty:
	'$' function=ReflectionFunction
;

enum ReflectionFunction:
	NAME = 'name' |
	SIGNATURE = 'signature' |
	CLASS ='classname' |
	RETURN_TYPE = 'return-type'
;

/* ------------------------------- */
/* pointcut                        */

Pointcut:
	(annotation=Annotation)?
	'pointcut' name=ID
	'class' location=LocationQuery 
	('operation' operation=OperationQuery)?
;

Annotation:
	'@' name=ID value=STRING  
;

LocationQuery:
	node=Node (('.' specialization=LocationQuery) | (composition=CompositionQuery))?
;

CompositionQuery: {CompositionQuery}
	(modifier=QueryModifier)? '{' (subQueries += LocationQuery)* '}'	
;

enum QueryModifier:
	INCLUDE = 'include' |
	EXCLUDE = 'exclude'
;

OperationQuery: {OperationQuery}
	modifier=[structure::OperationModifier|ID]?
	returnType=[structure::Type|ID]? 
	(
		(
			operationReference=[structure::Operation|ID] 
			('(' parameterQueries+=ParameterQuery (',' parameterQueries+=ParameterQuery)* ')')? 
		) | 
		'*'
	)
;

ParameterQuery: {ParameterQuery}
	modifier=[structure::ParameterModifier|ID]?
	(type=[structure::Type|ID]| '*')
	parameter=[structure::Parameter|ID]?
;

Node:
	(SubPathNode | WildcardNode | ParentNode | ContainerNode) ('[' constraint=PropertyConstraint ']')?  
;

ContainerNode:
	container=[structure::Container|ID]
;

WildcardNode: {WildcardNode}
	'*'
;

SubPathNode: {SubPathNode}
	'**'
;

ParentNode: {ParentNode}
	'up'
;

PropertyConstraint returns PropertyConstraintExpression: 
	PropertyConstraintCompare ({PropertyConstraintExpression.left=current} logic=LogicOperator right=PropertyConstraintCompare)?
;

enum LogicOperator:
	AND = '&&' |
	OR = '||'
;

PropertyConstraintCompare returns PropertyConstraintExpression:
	ConstraintElement ({PropertyConstraintExpression.left=current} compare=CompareOperator right=ConstraintElement)?
;

enum CompareOperator:
	EQ = '=' |
	LIKE = '~' |
	NE = '!=' |
	GR = '>' |
	LW = '<' |
	GE = '>=' |
	LE = '<='
;

ConstraintElement:
	Literal | LocalQuery
;

LocalQuery:
	(locationQuery=LocationQuery)? (property=ModelProperty | typeof=Typeof)
;

ModelProperty:
	 '#' reference=[structure::Feature|ID]
;

Typeof:
	'istypeof' '(' reference=[structure::Type|ID] ')'
;

/* ------------------------------- */
/* literals                        */

Literal:
	StringLiteral | IntLiteral | FloatLiteral
;

FloatLiteral:
	value=FLOAT
;

IntLiteral:
	value=INT
;

StringLiteral:
	value=STRING
;

/* ------------------------------- */
/* Terminals and literal rules     */

QualifiedName:
  ID (=>'.' ID)*;

QualifiedNameWithWildcard:
	QualifiedName ('.' '*')?
;

// Float Terminal    
// Make sure the Float rule does not shadow the INT rule
terminal FLOAT returns ecore::EFloatObject :
    NUMBER+ ('.' NUMBER*) (("e"|"E") ("+"|"-")? NUMBER+)? 'f'? |
    NUMBER+ 'f';
    
// Number Terminal
terminal fragment NUMBER :
    '0'..'9';


// Integer Terminal
// An INT is a list of numbers.   
terminal INT returns ecore::EInt:
    NUMBER+;

