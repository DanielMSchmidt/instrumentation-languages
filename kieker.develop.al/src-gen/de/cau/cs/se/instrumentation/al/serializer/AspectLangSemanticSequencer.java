/*
 * generated by Xtext
 */
package kieker.develop.al.serializer;

import com.google.inject.Inject;
import kieker.develop.al.aspectLang.Advice;
import kieker.develop.al.aspectLang.AdviceParameter;
import kieker.develop.al.aspectLang.AdviceParameterDeclaration;
import kieker.develop.al.aspectLang.Annotation;
import kieker.develop.al.aspectLang.ApplicationModel;
import kieker.develop.al.aspectLang.Aspect;
import kieker.develop.al.aspectLang.AspectLangPackage;
import kieker.develop.al.aspectLang.AspectModel;
import kieker.develop.al.aspectLang.Collector;
import kieker.develop.al.aspectLang.CompositionQuery;
import kieker.develop.al.aspectLang.ContainerNode;
import kieker.develop.al.aspectLang.Event;
import kieker.develop.al.aspectLang.FloatLiteral;
import kieker.develop.al.aspectLang.Import;
import kieker.develop.al.aspectLang.IntLiteral;
import kieker.develop.al.aspectLang.InternalFunctionProperty;
import kieker.develop.al.aspectLang.LocalQuery;
import kieker.develop.al.aspectLang.LocationQuery;
import kieker.develop.al.aspectLang.ModelProperty;
import kieker.develop.al.aspectLang.OperationQuery;
import kieker.develop.al.aspectLang.ParameterQuery;
import kieker.develop.al.aspectLang.ParentNode;
import kieker.develop.al.aspectLang.Pointcut;
import kieker.develop.al.aspectLang.PropertyConstraint;
import kieker.develop.al.aspectLang.PropertyConstraintCompare;
import kieker.develop.al.aspectLang.ReferenceValue;
import kieker.develop.al.aspectLang.ReflectionProperty;
import kieker.develop.al.aspectLang.RuntimeProperty;
import kieker.develop.al.aspectLang.StringLiteral;
import kieker.develop.al.aspectLang.SubPathNode;
import kieker.develop.al.aspectLang.TypeReference;
import kieker.develop.al.aspectLang.Typeof;
import kieker.develop.al.aspectLang.UtilizeAdvice;
import kieker.develop.al.aspectLang.WildcardNode;
import kieker.develop.al.services.AspectLangGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class AspectLangSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private AspectLangGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == AspectLangPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case AspectLangPackage.ADVICE:
				sequence_Advice(context, (Advice) semanticObject); 
				return; 
			case AspectLangPackage.ADVICE_PARAMETER:
				sequence_AdviceParameter(context, (AdviceParameter) semanticObject); 
				return; 
			case AspectLangPackage.ADVICE_PARAMETER_DECLARATION:
				sequence_AdviceParameterDeclaration(context, (AdviceParameterDeclaration) semanticObject); 
				return; 
			case AspectLangPackage.ANNOTATION:
				sequence_Annotation(context, (Annotation) semanticObject); 
				return; 
			case AspectLangPackage.APPLICATION_MODEL:
				sequence_ApplicationModel(context, (ApplicationModel) semanticObject); 
				return; 
			case AspectLangPackage.ASPECT:
				sequence_Aspect(context, (Aspect) semanticObject); 
				return; 
			case AspectLangPackage.ASPECT_MODEL:
				sequence_AspectModel(context, (AspectModel) semanticObject); 
				return; 
			case AspectLangPackage.COLLECTOR:
				sequence_Collector(context, (Collector) semanticObject); 
				return; 
			case AspectLangPackage.COMPOSITION_QUERY:
				sequence_CompositionQuery(context, (CompositionQuery) semanticObject); 
				return; 
			case AspectLangPackage.CONTAINER_NODE:
				if (rule == grammarAccess.getContainerNodeRule()) {
					sequence_ContainerNode(context, (ContainerNode) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNodeRule()) {
					sequence_ContainerNode_Node(context, (ContainerNode) semanticObject); 
					return; 
				}
				else break;
			case AspectLangPackage.EVENT:
				sequence_Event(context, (Event) semanticObject); 
				return; 
			case AspectLangPackage.FLOAT_LITERAL:
				sequence_FloatLiteral(context, (FloatLiteral) semanticObject); 
				return; 
			case AspectLangPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case AspectLangPackage.INT_LITERAL:
				sequence_IntLiteral(context, (IntLiteral) semanticObject); 
				return; 
			case AspectLangPackage.INTERNAL_FUNCTION_PROPERTY:
				sequence_InternalFunctionProperty(context, (InternalFunctionProperty) semanticObject); 
				return; 
			case AspectLangPackage.LOCAL_QUERY:
				sequence_LocalQuery(context, (LocalQuery) semanticObject); 
				return; 
			case AspectLangPackage.LOCATION_QUERY:
				sequence_LocationQuery(context, (LocationQuery) semanticObject); 
				return; 
			case AspectLangPackage.MODEL_PROPERTY:
				sequence_ModelProperty(context, (ModelProperty) semanticObject); 
				return; 
			case AspectLangPackage.OPERATION_QUERY:
				sequence_OperationQuery(context, (OperationQuery) semanticObject); 
				return; 
			case AspectLangPackage.PARAMETER_QUERY:
				sequence_ParameterQuery(context, (ParameterQuery) semanticObject); 
				return; 
			case AspectLangPackage.PARENT_NODE:
				if (rule == grammarAccess.getNodeRule()) {
					sequence_Node_ParentNode(context, (ParentNode) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getParentNodeRule()) {
					sequence_ParentNode(context, (ParentNode) semanticObject); 
					return; 
				}
				else break;
			case AspectLangPackage.POINTCUT:
				sequence_Pointcut(context, (Pointcut) semanticObject); 
				return; 
			case AspectLangPackage.PROPERTY_CONSTRAINT:
				sequence_PropertyConstraint(context, (PropertyConstraint) semanticObject); 
				return; 
			case AspectLangPackage.PROPERTY_CONSTRAINT_COMPARE:
				sequence_PropertyConstraintCompare(context, (PropertyConstraintCompare) semanticObject); 
				return; 
			case AspectLangPackage.REFERENCE_VALUE:
				sequence_ReferenceValue(context, (ReferenceValue) semanticObject); 
				return; 
			case AspectLangPackage.REFLECTION_PROPERTY:
				sequence_ReflectionProperty(context, (ReflectionProperty) semanticObject); 
				return; 
			case AspectLangPackage.RUNTIME_PROPERTY:
				sequence_RuntimeProperty(context, (RuntimeProperty) semanticObject); 
				return; 
			case AspectLangPackage.STRING_LITERAL:
				sequence_StringLiteral(context, (StringLiteral) semanticObject); 
				return; 
			case AspectLangPackage.SUB_PATH_NODE:
				if (rule == grammarAccess.getNodeRule()) {
					sequence_Node_SubPathNode(context, (SubPathNode) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSubPathNodeRule()) {
					sequence_SubPathNode(context, (SubPathNode) semanticObject); 
					return; 
				}
				else break;
			case AspectLangPackage.TYPE_REFERENCE:
				sequence_TypeReference(context, (TypeReference) semanticObject); 
				return; 
			case AspectLangPackage.TYPEOF:
				sequence_Typeof(context, (Typeof) semanticObject); 
				return; 
			case AspectLangPackage.UTILIZE_ADVICE:
				sequence_UtilizeAdvice(context, (UtilizeAdvice) semanticObject); 
				return; 
			case AspectLangPackage.WILDCARD_NODE:
				if (rule == grammarAccess.getNodeRule()) {
					sequence_Node_WildcardNode(context, (WildcardNode) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getWildcardNodeRule()) {
					sequence_WildcardNode(context, (WildcardNode) semanticObject); 
					return; 
				}
				else break;
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AdviceParameterDeclaration returns AdviceParameterDeclaration
	 *
	 * Constraint:
	 *     (type=TypeReference name=ID)
	 */
	protected void sequence_AdviceParameterDeclaration(ISerializationContext context, AdviceParameterDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AspectLangPackage.Literals.ADVICE_PARAMETER_DECLARATION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AspectLangPackage.Literals.ADVICE_PARAMETER_DECLARATION__TYPE));
			if (transientValues.isValueTransient(semanticObject, AspectLangPackage.Literals.ADVICE_PARAMETER_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AspectLangPackage.Literals.ADVICE_PARAMETER_DECLARATION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdviceParameterDeclarationAccess().getTypeTypeReferenceParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getAdviceParameterDeclarationAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Value returns AdviceParameter
	 *     AdviceParameter returns AdviceParameter
	 *
	 * Constraint:
	 *     (declaration=[AdviceParameterDeclaration|ID] collection=Value?)
	 */
	protected void sequence_AdviceParameter(ISerializationContext context, AdviceParameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Advice returns Advice
	 *
	 * Constraint:
	 *     (name=ID (parameterDeclarations+=AdviceParameterDeclaration parameterDeclarations+=AdviceParameterDeclaration*)? collectors+=Collector*)
	 */
	protected void sequence_Advice(ISerializationContext context, Advice semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Annotation returns Annotation
	 *
	 * Constraint:
	 *     (name='technology' technologies+=Technology technologies+=Technology)
	 */
	protected void sequence_Annotation(ISerializationContext context, Annotation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ApplicationModel returns ApplicationModel
	 *
	 * Constraint:
	 *     (handler=ID name=ID model=STRING)
	 */
	protected void sequence_ApplicationModel(ISerializationContext context, ApplicationModel semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AspectLangPackage.Literals.APPLICATION_MODEL__HANDLER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AspectLangPackage.Literals.APPLICATION_MODEL__HANDLER));
			if (transientValues.isValueTransient(semanticObject, AspectLangPackage.Literals.APPLICATION_MODEL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AspectLangPackage.Literals.APPLICATION_MODEL__NAME));
			if (transientValues.isValueTransient(semanticObject, AspectLangPackage.Literals.APPLICATION_MODEL__MODEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AspectLangPackage.Literals.APPLICATION_MODEL__MODEL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getApplicationModelAccess().getHandlerIDTerminalRuleCall_1_0(), semanticObject.getHandler());
		feeder.accept(grammarAccess.getApplicationModelAccess().getNameIDTerminalRuleCall_3_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getApplicationModelAccess().getModelSTRINGTerminalRuleCall_4_0(), semanticObject.getModel());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AspectModel returns AspectModel
	 *
	 * Constraint:
	 *     (name=QualifiedName imports+=Import* sources+=ApplicationModel* (advices+=Advice | pointcuts+=Pointcut | aspects+=Aspect)*)
	 */
	protected void sequence_AspectModel(ISerializationContext context, AspectModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Aspect returns Aspect
	 *
	 * Constraint:
	 *     (pointcut=[Pointcut|QualifiedName] advices+=UtilizeAdvice advices+=UtilizeAdvice*)
	 */
	protected void sequence_Aspect(ISerializationContext context, Aspect semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Collector returns Collector
	 *
	 * Constraint:
	 *     (insertionPoint=InsertionPoint events+=Event+)
	 */
	protected void sequence_Collector(ISerializationContext context, Collector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CompositionQuery returns CompositionQuery
	 *
	 * Constraint:
	 *     (modifier=QueryModifier? subQueries+=LocationQuery*)
	 */
	protected void sequence_CompositionQuery(ISerializationContext context, CompositionQuery semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContainerNode returns ContainerNode
	 *
	 * Constraint:
	 *     container=[Feature|ID]
	 */
	protected void sequence_ContainerNode(ISerializationContext context, ContainerNode semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AspectLangPackage.Literals.CONTAINER_NODE__CONTAINER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AspectLangPackage.Literals.CONTAINER_NODE__CONTAINER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getContainerNodeAccess().getContainerFeatureIDTerminalRuleCall_0_1(), semanticObject.getContainer());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Node returns ContainerNode
	 *
	 * Constraint:
	 *     (container=[Feature|ID] constraint=PropertyConstraint?)
	 */
	protected void sequence_ContainerNode_Node(ISerializationContext context, ContainerNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Event returns Event
	 *
	 * Constraint:
	 *     (type=[RecordType|QualifiedName] (initializations+=Value initializations+=Value*)?)
	 */
	protected void sequence_Event(ISerializationContext context, Event semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Value returns FloatLiteral
	 *     PropertyConstraint returns FloatLiteral
	 *     PropertyConstraint.PropertyConstraint_1_0 returns FloatLiteral
	 *     PropertyConstraintCompare returns FloatLiteral
	 *     PropertyConstraintCompare.PropertyConstraintCompare_1_0 returns FloatLiteral
	 *     ConstraintElement returns FloatLiteral
	 *     Literal returns FloatLiteral
	 *     FloatLiteral returns FloatLiteral
	 *
	 * Constraint:
	 *     value=FLOAT
	 */
	protected void sequence_FloatLiteral(ISerializationContext context, FloatLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AspectLangPackage.Literals.FLOAT_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AspectLangPackage.Literals.FLOAT_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFloatLiteralAccess().getValueFLOATTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     importedNamespace=QualifiedNameWithWildcard
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AspectLangPackage.Literals.IMPORT__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AspectLangPackage.Literals.IMPORT__IMPORTED_NAMESPACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Value returns IntLiteral
	 *     PropertyConstraint returns IntLiteral
	 *     PropertyConstraint.PropertyConstraint_1_0 returns IntLiteral
	 *     PropertyConstraintCompare returns IntLiteral
	 *     PropertyConstraintCompare.PropertyConstraintCompare_1_0 returns IntLiteral
	 *     ConstraintElement returns IntLiteral
	 *     Literal returns IntLiteral
	 *     IntLiteral returns IntLiteral
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_IntLiteral(ISerializationContext context, IntLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AspectLangPackage.Literals.INT_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AspectLangPackage.Literals.INT_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntLiteralAccess().getValueINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Value returns InternalFunctionProperty
	 *     InternalFunctionProperty returns InternalFunctionProperty
	 *
	 * Constraint:
	 *     function=InternalFunction
	 */
	protected void sequence_InternalFunctionProperty(ISerializationContext context, InternalFunctionProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AspectLangPackage.Literals.INTERNAL_FUNCTION_PROPERTY__FUNCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AspectLangPackage.Literals.INTERNAL_FUNCTION_PROPERTY__FUNCTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInternalFunctionPropertyAccess().getFunctionInternalFunctionEnumRuleCall_0(), semanticObject.getFunction());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PropertyConstraint returns LocalQuery
	 *     PropertyConstraint.PropertyConstraint_1_0 returns LocalQuery
	 *     PropertyConstraintCompare returns LocalQuery
	 *     PropertyConstraintCompare.PropertyConstraintCompare_1_0 returns LocalQuery
	 *     ConstraintElement returns LocalQuery
	 *     LocalQuery returns LocalQuery
	 *
	 * Constraint:
	 *     (locationQuery=LocationQuery? (property=ModelProperty | typeof=Typeof))
	 */
	protected void sequence_LocalQuery(ISerializationContext context, LocalQuery semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LocationQuery returns LocationQuery
	 *
	 * Constraint:
	 *     (node=Node (specialization=LocationQuery | composition=CompositionQuery)?)
	 */
	protected void sequence_LocationQuery(ISerializationContext context, LocationQuery semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelProperty returns ModelProperty
	 *
	 * Constraint:
	 *     reference=[Feature|ID]
	 */
	protected void sequence_ModelProperty(ISerializationContext context, ModelProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AspectLangPackage.Literals.MODEL_PROPERTY__REFERENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AspectLangPackage.Literals.MODEL_PROPERTY__REFERENCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getModelPropertyAccess().getReferenceFeatureIDTerminalRuleCall_1_0_1(), semanticObject.getReference());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Node returns ParentNode
	 *
	 * Constraint:
	 *     constraint=PropertyConstraint?
	 */
	protected void sequence_Node_ParentNode(ISerializationContext context, ParentNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Node returns SubPathNode
	 *
	 * Constraint:
	 *     constraint=PropertyConstraint?
	 */
	protected void sequence_Node_SubPathNode(ISerializationContext context, SubPathNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Node returns WildcardNode
	 *
	 * Constraint:
	 *     constraint=PropertyConstraint?
	 */
	protected void sequence_Node_WildcardNode(ISerializationContext context, WildcardNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OperationQuery returns OperationQuery
	 *
	 * Constraint:
	 *     (
	 *         modifier=[OperationModifier|ID]? 
	 *         returnType=TypeReference? 
	 *         (operationReference=[Operation|ID] (parameterQueries+=ParameterQuery parameterQueries+=ParameterQuery*)?)?
	 *     )
	 */
	protected void sequence_OperationQuery(ISerializationContext context, OperationQuery semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParameterQuery returns ParameterQuery
	 *
	 * Constraint:
	 *     (modifier=[ParameterModifier|ID]? type=TypeReference? parameter=[Parameter|ID]?)
	 */
	protected void sequence_ParameterQuery(ISerializationContext context, ParameterQuery semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParentNode returns ParentNode
	 *
	 * Constraint:
	 *     {ParentNode}
	 */
	protected void sequence_ParentNode(ISerializationContext context, ParentNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Pointcut returns Pointcut
	 *
	 * Constraint:
	 *     (annotation=Annotation? name=ID model=[ApplicationModel|ID] location=LocationQuery operation=OperationQuery?)
	 */
	protected void sequence_Pointcut(ISerializationContext context, Pointcut semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyConstraint returns PropertyConstraintCompare
	 *     PropertyConstraint.PropertyConstraint_1_0 returns PropertyConstraintCompare
	 *     PropertyConstraintCompare returns PropertyConstraintCompare
	 *
	 * Constraint:
	 *     (left=PropertyConstraintCompare_PropertyConstraintCompare_1_0 compare=CompareOperator right=ConstraintElement)
	 */
	protected void sequence_PropertyConstraintCompare(ISerializationContext context, PropertyConstraintCompare semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AspectLangPackage.Literals.PROPERTY_CONSTRAINT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AspectLangPackage.Literals.PROPERTY_CONSTRAINT__LEFT));
			if (transientValues.isValueTransient(semanticObject, AspectLangPackage.Literals.PROPERTY_CONSTRAINT_COMPARE__COMPARE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AspectLangPackage.Literals.PROPERTY_CONSTRAINT_COMPARE__COMPARE));
			if (transientValues.isValueTransient(semanticObject, AspectLangPackage.Literals.PROPERTY_CONSTRAINT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AspectLangPackage.Literals.PROPERTY_CONSTRAINT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPropertyConstraintCompareAccess().getPropertyConstraintCompareLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPropertyConstraintCompareAccess().getCompareCompareOperatorEnumRuleCall_1_1_0(), semanticObject.getCompare());
		feeder.accept(grammarAccess.getPropertyConstraintCompareAccess().getRightConstraintElementParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PropertyConstraint returns PropertyConstraint
	 *
	 * Constraint:
	 *     (left=PropertyConstraint_PropertyConstraint_1_0 logic=LogicOperator right=PropertyConstraintCompare)
	 */
	protected void sequence_PropertyConstraint(ISerializationContext context, PropertyConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AspectLangPackage.Literals.PROPERTY_CONSTRAINT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AspectLangPackage.Literals.PROPERTY_CONSTRAINT__LEFT));
			if (transientValues.isValueTransient(semanticObject, AspectLangPackage.Literals.PROPERTY_CONSTRAINT__LOGIC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AspectLangPackage.Literals.PROPERTY_CONSTRAINT__LOGIC));
			if (transientValues.isValueTransient(semanticObject, AspectLangPackage.Literals.PROPERTY_CONSTRAINT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AspectLangPackage.Literals.PROPERTY_CONSTRAINT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPropertyConstraintAccess().getPropertyConstraintLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPropertyConstraintAccess().getLogicLogicOperatorEnumRuleCall_1_1_0(), semanticObject.getLogic());
		feeder.accept(grammarAccess.getPropertyConstraintAccess().getRightPropertyConstraintCompareParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Value returns ReferenceValue
	 *     ReferenceValue returns ReferenceValue
	 *
	 * Constraint:
	 *     (query=LocationQuery? property=Property)
	 */
	protected void sequence_ReferenceValue(ISerializationContext context, ReferenceValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Property returns ReflectionProperty
	 *     ReflectionProperty returns ReflectionProperty
	 *
	 * Constraint:
	 *     function=ReflectionFunction
	 */
	protected void sequence_ReflectionProperty(ISerializationContext context, ReflectionProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AspectLangPackage.Literals.REFLECTION_PROPERTY__FUNCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AspectLangPackage.Literals.REFLECTION_PROPERTY__FUNCTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReflectionPropertyAccess().getFunctionReflectionFunctionEnumRuleCall_1_0(), semanticObject.getFunction());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Property returns RuntimeProperty
	 *     RuntimeProperty returns RuntimeProperty
	 *
	 * Constraint:
	 *     {RuntimeProperty}
	 */
	protected void sequence_RuntimeProperty(ISerializationContext context, RuntimeProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Value returns StringLiteral
	 *     PropertyConstraint returns StringLiteral
	 *     PropertyConstraint.PropertyConstraint_1_0 returns StringLiteral
	 *     PropertyConstraintCompare returns StringLiteral
	 *     PropertyConstraintCompare.PropertyConstraintCompare_1_0 returns StringLiteral
	 *     ConstraintElement returns StringLiteral
	 *     Literal returns StringLiteral
	 *     StringLiteral returns StringLiteral
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_StringLiteral(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AspectLangPackage.Literals.STRING_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AspectLangPackage.Literals.STRING_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SubPathNode returns SubPathNode
	 *
	 * Constraint:
	 *     {SubPathNode}
	 */
	protected void sequence_SubPathNode(ISerializationContext context, SubPathNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeReference returns TypeReference
	 *
	 * Constraint:
	 *     (context=[ApplicationModel|ID] reference=[NamedType|ID] collection?='[]'?)
	 */
	protected void sequence_TypeReference(ISerializationContext context, TypeReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Typeof returns Typeof
	 *
	 * Constraint:
	 *     reference=TypeReference
	 */
	protected void sequence_Typeof(ISerializationContext context, Typeof semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AspectLangPackage.Literals.TYPEOF__REFERENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AspectLangPackage.Literals.TYPEOF__REFERENCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeofAccess().getReferenceTypeReferenceParserRuleCall_2_0(), semanticObject.getReference());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     UtilizeAdvice returns UtilizeAdvice
	 *
	 * Constraint:
	 *     (advice=[Advice|QualifiedName] (parameterAssignments+=Value parameterAssignments+=Value*)?)
	 */
	protected void sequence_UtilizeAdvice(ISerializationContext context, UtilizeAdvice semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WildcardNode returns WildcardNode
	 *
	 * Constraint:
	 *     {WildcardNode}
	 */
	protected void sequence_WildcardNode(ISerializationContext context, WildcardNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
