/*
 * generated by Xtext
 */
package de.cau.cs.se.instrumentation.rl.validation

import org.eclipse.xtext.validation.Check
import de.cau.cs.se.instrumentation.rl.recordLang.RecordLangPackage
import de.cau.cs.se.instrumentation.rl.recordLang.Property
import de.cau.cs.se.instrumentation.rl.recordLang.RecordType
import org.eclipse.emf.common.util.EList
import de.cau.cs.se.instrumentation.rl.recordLang.PartialRecordType
import de.cau.cs.se.instrumentation.rl.recordLang.Type
import org.eclipse.xtext.xbase.lib.Pair

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class RecordLangValidator extends AbstractRecordLangValidator {

  	public static val INVALID_NAME = 'invalidName'

	@Check
	def checkPropertyDeclaration(Property property) {
		if (property.eContainer instanceof RecordType) {
			if (PropertyEvaluation::collectAllProperties(property.eContainer as RecordType).exists[p | p.name.equals(property.name) && p != property]) {
				val Type type = PropertyEvaluation::collectAllProperties(property.eContainer as RecordType).findFirst[p | p.name.equals(property.name) && p != property].eContainer as Type
				error('Property has been defined in ' + type.name + '. Cannot be declared again.', 
					RecordLangPackage$Literals::PROPERTY__NAME,
					INVALID_NAME)
			}
		} else if (property.eContainer instanceof PartialRecordType) {
			if (PropertyEvaluation::collectAllProperties(property.eContainer as PartialRecordType).exists[p | p.name.equals(property.name) && p != property]) {
				val Type type = PropertyEvaluation::collectAllProperties(property.eContainer as PartialRecordType).findFirst[p | p.name.equals(property.name) && p != property].eContainer as Type
				error('Property has been defined in ' + type.name + '. Cannot be declared again.', 
					RecordLangPackage$Literals::PROPERTY__NAME,
					INVALID_NAME)
			}
		}
	}
	
	@Check
	def checkRecordTypeComposition(RecordType type) {
		val EList<Property> properties = PropertyEvaluation::collectAllProperties(type)
		if (properties.exists[p | properties.exists[pInner | p.name.equals(pInner.name) && p != pInner]]) {
			val EList<Pair<Property,Property>> duplicates = new org.eclipse.emf.common.util.BasicEList<Pair<Property,Property>>()
			properties.forEach[p | duplicates.add(p.findDuplicate(properties))]
			duplicates.forEach[entry |
				error('Multiple property inheritance of ' + entry.key.name + 
							' from ' + (entry.key.eContainer as Type).name + ' and ' + (entry.value.eContainer as Type).name, 
							RecordLangPackage$Literals::PARTIAL_RECORD_TYPE__PARENTS,
							INVALID_NAME)
			]
		}
	}
	
	def Pair<Property, Property> findDuplicate(Property property, EList<Property> properties) {
		val Property second = properties.findFirst[p | property.name.equals(p.name) && p != property]
		return new Pair(property,second)
	}
	
	@Check
	def checkPartialTypeComposition(PartialRecordType type) {
		val EList<Property> properties = PropertyEvaluation::collectAllProperties(type)
		if (properties.exists[p | properties.exists[pInner | p.name.equals(pInner.name) && p != pInner]]) {
			val EList<Pair<Property,Property>> duplicates = new org.eclipse.emf.common.util.BasicEList<Pair<Property,Property>>()
			properties.forEach[p | duplicates.add(p.findDuplicate(properties))]
			duplicates.forEach[entry |
				error('Multiple property inheritance of ' + entry.key.name + 
							' from ' + (entry.key.eContainer as Type).name + ' and ' + (entry.value.eContainer as Type).name, 
							RecordLangPackage$Literals::PARTIAL_RECORD_TYPE__PARENTS,
							INVALID_NAME)
			]
		}
	}
	
}
