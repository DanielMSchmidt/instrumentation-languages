package kieker.develop.rl.generator.javascript;

import java.io.File;
import java.util.Calendar;
import java.util.Collection;
import java.util.List;
import kieker.develop.rl.generator.AbstractRecordTypeGenerator;
import kieker.develop.rl.generator.InternalErrorException;
import kieker.develop.rl.recordLang.BaseType;
import kieker.develop.rl.recordLang.Classifier;
import kieker.develop.rl.recordLang.Model;
import kieker.develop.rl.recordLang.Property;
import kieker.develop.rl.recordLang.RecordType;
import kieker.develop.rl.recordLang.Type;
import kieker.develop.rl.typing.BaseTypes;
import kieker.develop.rl.validation.PropertyEvaluation;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;

/**
 * @author Daniel Schmidt
 */
@SuppressWarnings("all")
public class RecordTypeGenerator extends AbstractRecordTypeGenerator {
  /**
   * Return the unique id.
   */
  @Override
  public String getId() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("javascript");
    return _builder.toString();
  }
  
  /**
   * Return the preferences activation description.
   */
  @Override
  public String getDescription() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("Javascript record generator");
    return _builder.toString();
  }
  
  /**
   * No Javascript structures for abstract record types.
   */
  @Override
  public boolean supportsAbstractRecordType() {
    return false;
  }
  
  /**
   * Compute the directory name for a record type.
   */
  @Override
  public CharSequence getDirectoryName(final Type type) {
    StringConcatenation _builder = new StringConcatenation();
    EObject _eContainer = type.eContainer();
    String _name = ((Model) _eContainer).getName();
    String _replace = _name.replace(".", File.separator);
    _builder.append(_replace, "");
    return _builder;
  }
  
  /**
   * Return the extension used for the file type generated by this generator.
   */
  @Override
  public String getFileName(final Type type) {
    StringConcatenation _builder = new StringConcatenation();
    CharSequence _directoryName = this.getDirectoryName(type);
    _builder.append(_directoryName, "");
    _builder.append(File.separator, "");
    String _name = type.getName();
    _builder.append(_name, "");
    _builder.append(".js");
    return _builder.toString();
  }
  
  @Override
  public String getOutletType() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("javascript");
    return _builder.toString();
  }
  
  public String fullyQualifiedName(final RecordType type) {
    StringConcatenation _builder = new StringConcatenation();
    EObject _eContainer = type.eContainer();
    String _name = ((Model) _eContainer).getName();
    _builder.append(_name, "");
    _builder.append(".");
    String _name_1 = type.getName();
    _builder.append(_name_1, "");
    return _builder.toString();
  }
  
  private String defaultValues(final Classifier classifier) throws InternalErrorException {
    String _switchResult = null;
    BaseType _type = classifier.getType();
    BaseTypes _typeEnum = BaseTypes.getTypeEnum(_type);
    if (_typeEnum != null) {
      switch (_typeEnum) {
        case STRING:
          _switchResult = "\'\'";
          break;
        case BYTE:
          _switchResult = "undefined";
          break;
        case SHORT:
          _switchResult = "0";
          break;
        case INT:
          _switchResult = "0";
          break;
        case LONG:
          _switchResult = "0";
          break;
        case FLOAT:
          _switchResult = "0";
          break;
        case DOUBLE:
          _switchResult = "0";
          break;
        case CHAR:
          _switchResult = "\'\'";
          break;
        case BOOLEAN:
          _switchResult = "false";
          break;
        default:
          break;
      }
    }
    return _switchResult;
  }
  
  /**
   * Create a javascript based record for kieker
   * TODO: Make sure that possible naming collision won't cause problems / fix them
   */
  @Override
  public CharSequence createContent(final RecordType type, final String author, final String version, final String headerComment) {
    StringConcatenation _builder = new StringConcatenation();
    {
      boolean _equals = headerComment.equals("");
      boolean _not = (!_equals);
      if (_not) {
        Calendar _instance = Calendar.getInstance();
        int _get = _instance.get(Calendar.YEAR);
        String _string = Integer.valueOf(_get).toString();
        String _replace = headerComment.replace("THIS-YEAR", _string);
        _builder.append(_replace, "");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("\'use strict\';");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("module.exports = function get");
    String _name = type.getName();
    _builder.append(_name, "");
    _builder.append(" (record) {");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("return {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("class: \'");
    String _fullyQualifiedName = this.fullyQualifiedName(type);
    _builder.append(_fullyQualifiedName, "\t\t");
    _builder.append("\',");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("timestamp: record.timestamp,");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("values: [");
    List<Property> _collectAllDataProperties = PropertyEvaluation.collectAllDataProperties(type);
    String _createRecordValues = this.createRecordValues(_collectAllDataProperties);
    _builder.append(_createRecordValues, "\t\t");
    _builder.append("]");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("};");
    _builder.newLine();
    _builder.append("};");
    _builder.newLine();
    return _builder;
  }
  
  /**
   * Creates the values for the kieker record in the right order
   * TODO: cast to string
   */
  public String createRecordValues(final Collection<Property> list) {
    final Function1<Property, String> _function = (Property e) -> {
      try {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("record.");
        String _name = e.getName();
        _builder.append(_name, "");
        _builder.append(" || ");
        Classifier _findType = PropertyEvaluation.findType(e);
        String _defaultValues = this.defaultValues(_findType);
        _builder.append(_defaultValues, "");
        return _builder.toString();
      } catch (Throwable _e) {
        throw Exceptions.sneakyThrow(_e);
      }
    };
    Iterable<String> _map = IterableExtensions.<Property, String>map(list, _function);
    return IterableExtensions.join(_map, ", ");
  }
}
