package kieker.develop.rl.generator.javascript

import kieker.develop.rl.recordLang.Type
import kieker.develop.rl.recordLang.RecordType
import kieker.develop.rl.recordLang.Model
import kieker.develop.rl.recordLang.Property
import java.io.File
import kieker.develop.rl.generator.AbstractRecordTypeGenerator
import kieker.develop.rl.validation.PropertyEvaluation
import java.util.Collection
import java.util.Calendar
import kieker.develop.rl.generator.InternalErrorException
import kieker.develop.rl.recordLang.Classifier
import kieker.develop.rl.typing.BaseTypes

/**
 * @author Daniel Schmidt
 */
class RecordTypeGenerator extends AbstractRecordTypeGenerator {

	/**
	 * Return the unique id.
	 */
	override getId() '''javascript'''
	
	/**
	 * Return the preferences activation description.
	 */
	override getDescription() '''Javascript record generator'''
	
	/**
	 * No Javascript structures for abstract record types.
	 */
	override boolean supportsAbstractRecordType()  { false }

	/**
	 * Compute the directory name for a record type.
	 */
	override getDirectoryName(Type type) '''«(type.eContainer as Model).name.replace('.',File::separator)»'''
		
	/**
	 * Return the extension used for the file type generated by this generator. 
	 */
	override getFileName(Type type) '''«type.getDirectoryName»«File::separator»«type.name».js'''
		
	override getOutletType() '''javascript'''

	def String fullyQualifiedName(RecordType type) '''«(type.eContainer as Model).name».«type.name»'''
	
	private def defaultValues(Classifier classifier) throws InternalErrorException {
		switch (BaseTypes.getTypeEnum(classifier.type)) {
			case STRING : '\'\''
			case BYTE : 'undefined'
			case SHORT : '0'
			case INT : '0'
			case LONG : '0'
			case FLOAT : '0'
			case DOUBLE : '0'
			case CHAR : '\'\''
			case BOOLEAN : 'false'
		}
	}
	
	/**
	 * Create a javascript based record for kieker
	 * TODO: Make sure that possible naming collision won't cause problems / fix them 
	 */
	override createContent(RecordType type, String author, String version, String headerComment) {
		'''
		«IF (!headerComment.equals(""))»«headerComment.replace("THIS-YEAR", Calendar.getInstance().get(Calendar.YEAR).toString)»
		«ENDIF»'use strict';
		
		module.exports = function get«type.name» (record) {
			return {
				class: '«type.fullyQualifiedName»',
				timestamp: record.timestamp,
				values: [«PropertyEvaluation::collectAllDataProperties(type).createRecordValues»]
			};
		};
		'''
	}

		
	/**
	 * Creates the values for the kieker record in the right order
	 * TODO: cast to string
	 */
	def createRecordValues(Collection<Property> list) {
		list.map[e | 
			'''record.«e.name» || «PropertyEvaluation::findType(e).defaultValues»'''
		].join(', ')
	}
}