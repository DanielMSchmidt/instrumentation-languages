grammar de.cau.se.instrumentation.language.ProbeLang with org.eclipse.xtext.xbase.Xbase 

generate probeLang "http://www.cau.de/se/instrumentation/language/ProbeLang"

import "http://www.eclipse.org/xtext/xbase/Xbase" as xbase 
import "http://www.eclipse.org/xtext/common/JavaVMTypes" as jvmTypes
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Model:
	'package' name = QualifiedName
	(imports += Import)*
	(types+=DataTypeDeclaration)*
	(patterns+=Pattern)*
	(probes+=Probe)*
;

DataTypeDeclaration:
	'type' name=ID
;


Import :
	'import' ePackage=[ecore::EPackage|STRING] 'as' name=ID
;

QualifiedNameWithWildcard:
	QualifiedName ('.' '*')?
;

Pattern:
	'pattern' name=ID '(' parameters+=Parameter (',' parameters+=Parameter)* ')' 
	(codeSequcene+=CodeElement)*
;

Parameter:
	name=ID
;

CodeElement:
	(toUpper?='#')? value=SimpleCodeElement	
;

SimpleCodeElement returns xbase::XExpression:
	XStringLiteral | ParameterRef 
;

ParameterRef:
	ref=[Parameter|ID]
;

Probe:
	'probe' name=ID '{'
		(record=RecordDeclaration)?
		(replacements+=Replacement)*
	'}'
;

RecordDeclaration:
	'record' '{' (properties+=Property)+ '}'
;

Property:
	type=[DataTypeDeclaration|ID] name=ID
;

Replacement:
	name=ID scope=Scope '{'
		(patterns+=PatternCall)*
	'}'
;

Scope:
	'scope' modelRef=QualifiedName (insertBefore?='<')? target=Alternative (insertAfter?='>')?
;

Alternative:
	orExpr+=Sequence ('|' orExpr+=Sequence)*	
;

Sequence:
	(andExpr+=Quantifier)+
;

Quantifier:
	item=Item (type=QuantifierType)?	
;

Item returns xbase::XExpression:
	Operator | XStringLiteral | Group
;

Operator:
	type=OperatorType
;

Group:
	'(' subTarget=Alternative ')'	
;

PatternCall:
	ref=[Pattern|ID] '(' values+=Value (',' values+=Value)* ')'
;

Value:
	(elements+=StringElement)+
;

StringElement:
	(toUpper?='#')? value=ValueElement
;

ValueElement returns xbase::XExpression:
	XStringLiteral | PatternCall | ScopeRefElement | PropertyReference
;

PropertyReference:
	ref=[Property|ID]
;


ScopeRefElement:
	//ref=[ecore::ENamedElement|QualifiedName]
	'@' ref=QualifiedName
;

/* */

enum QuantifierType:
	NONE_OR_MANY = '*' |
	OPTIONAL = '?' |
	ONE_OR_MANY = '+'	
;

enum OperatorType:
	ANY_CHAR = '.' |
	WHITE_SPACE = '\\s' |
	NON_WHITE_SPACE = '\\S' |
	WORD_CHAR = '\\w' |
	NON_WORD_CHAR = '\\W' |
	DIGIT = '\\d' |
	NON_DIGIT = '\\D' 
;
